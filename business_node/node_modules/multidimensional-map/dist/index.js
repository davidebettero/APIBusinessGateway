'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* An OrderedMap represents a Map which allows array-style indexing over the keys
 * While the normal map keeps insertion order, this gives an easier way to access arbitrary indicies without using iterators */
class OrderedMap {
    constructor(keyOrder = []) {
        this.map = new Map();
        this.order = [];
        this.order = keyOrder;
        for (const key of keyOrder) {
            this.map.set(key, null);
        }
    }
    append(key, value) {
        if (!this.map.has(key))
            this.order.push(key);
        this.map.set(key, value);
    }
    prepend(key, value) {
        if (!this.map.has(key))
            this.order.unshift(key);
        this.map.set(key, value);
    }
    has(key) {
        return this.map.has(key);
    }
    get(key) {
        return this.map.get(key);
    }
    getAt(index) {
        return this.map.get(this.order[index]);
    }
    getPairAt(index) {
        const mapKey = this.order[index];
        return [mapKey, this.map.get(mapKey)];
    }
    getKeyAt(index) {
        return this.order[index];
    }
    getKeys() {
        return this.order;
    }
    forEach(fn) {
        this.map.forEach(fn);
    }
    indexOf(key) {
        return this.order.indexOf(key);
    }
    delete(key) {
        const index = this.order.indexOf(key);
        if (index === -1)
            return false;
        this.order.splice(index, 1);
        return this.map.delete(key);
    }
    deleteAt(index) {
        const mapKey = this.order[index];
        this.order.splice(index, 1);
        return this.map.delete(mapKey);
    }
    clear() {
        this.map.clear();
        this.order = [];
    }
    get length() {
        return this.order.length;
    }
}

/* Gets the intersection of the Array type (not Set)
 * Implementation assumes that array items are unique */
function getArrayIntersection(...sets) {
    const numOfAppearances = new Map();
    sets.forEach(set => {
        set.forEach(item => {
            if (!numOfAppearances.has(item))
                numOfAppearances.set(item, 0);
            const incrementedValue = numOfAppearances.get(item) + 1;
            numOfAppearances.set(item, incrementedValue);
        });
    });
    const intersection = [];
    numOfAppearances.forEach((count, item) => {
        if (count === sets.length)
            intersection.push(item);
    });
    return intersection;
}
class MultidimensionalMap {
    constructor(dimensions, entries, order = {}) {
        this.entries = [];
        Object.keys(order).forEach(dimensionName => {
            if (!dimensions.includes(dimensionName))
                throw new Error(`Invalid dimension '${dimensionName}'`);
        });
        this.dimensions = dimensions.reduce((acc, curr) => {
            const startingOrder = order[curr];
            acc[curr] = new OrderedMap(startingOrder);
            return acc;
        }, {});
        if (entries) {
            this.addEntries(entries);
        }
    }
    addEntries(entries) {
        entries.forEach(entry => {
            this.entries.push(entry);
            Object.keys(this.dimensions).forEach(dimension => {
                const entryValueForDimension = entry[dimension];
                const dimensionMap = this.dimensions[dimension];
                if (dimensionMap.get(entryValueForDimension) === null || !dimensionMap.has(entryValueForDimension)) {
                    dimensionMap.append(entryValueForDimension, []);
                }
                dimensionMap.get(entryValueForDimension).push(entry);
            });
        });
    }
    getAllEntries() {
        return this.entries;
    }
    getEntriesInRange(dimension, start, end) {
        if (!this.dimensions.hasOwnProperty(dimension))
            throw new Error(`Dimension "${dimension}" does not exist`);
        const targetDimension = this.dimensions[dimension];
        const startIdx = start == null ? 0 : targetDimension.indexOf(start);
        const endIdx = end == null ? targetDimension.length - 1 : targetDimension.indexOf(end);
        if (startIdx === -1)
            throw new Error(`Range start "${start}" does not exist in dimension "${dimension}"`);
        if (endIdx === -1)
            throw new Error(`Range end "${end}" does not exist in dimension "${dimension}"`);
        const entryList = [];
        for (let i = startIdx; i <= endIdx; i++) {
            const entries = targetDimension.getAt(i);
            if (entries === null)
                continue;
            entryList.push(...entries);
        }
        return entryList;
    }
    getSubsetArray(query) {
        const subsets = Object.entries(query).map(([dimensionName, dimensionItem]) => {
            if (!this.dimensions.hasOwnProperty(dimensionName))
                throw new Error(`Dimension "${dimensionName}" does not exist`);
            if (typeof dimensionItem === 'object') {
                if (dimensionItem.range && dimensionItem.matches) {
                    throw new Error(`Must specify either "range" or "matches" property but not both`);
                }
                else if (dimensionItem.range) {
                    const [start, end] = dimensionItem.range;
                    return this.getEntriesInRange(dimensionName, start, end);
                }
                else if (dimensionItem.matches) {
                    const matchingEntries = [];
                    dimensionItem.matches.forEach((queryItem) => {
                        const matchResult = this.dimensions[dimensionName].get(queryItem);
                        if (matchResult === undefined)
                            throw new Error(`"${queryItem}" does not exist in dimension "${dimensionName}"`);
                        matchingEntries.push(...matchResult);
                    });
                    return matchingEntries;
                }
                else {
                    return this.entries;
                }
            }
            return this.dimensions[dimensionName].get(dimensionItem);
        });
        return getArrayIntersection(...subsets.filter(subset => subset != null));
    }
    getSubset(query, options = {}) {
        const { keepOrder = false } = options;
        const subsetArray = this.getSubsetArray(query);
        const ordering = {};
        if (keepOrder === true)
            Object.keys(this.dimensions).forEach(dimension => { ordering[dimension] = this.dimensions[dimension].order; });
        else if (Array.isArray(keepOrder) && keepOrder.length > 0)
            keepOrder.forEach(dimension => {
                if (this.dimensions[dimension] === undefined)
                    throw new Error(`Dimension '${dimension}' does not exist`);
                ordering[dimension] = this.dimensions[dimension].order;
            });
        const subsetMap = new MultidimensionalMap(Object.keys(this.dimensions), subsetArray, ordering);
        return subsetMap;
    }
    combineEntries(measures, dimensions, entries) {
        const dataEntries = entries ? entries : this.entries;
        const _measures = Array.isArray(measures) ? measures : [measures];
        const _dimensions = Array.isArray(dimensions) ? dimensions : [dimensions];
        if (dataEntries.length === 0)
            return {};
        const output = {};
        /* If no fields are given, simply sum over the measure */
        if (dimensions == null || dimensions.length === 0) {
            dataEntries.forEach(entry => {
                _measures.forEach(measure => {
                    if (output[measure] == null)
                        output[measure] = 0;
                    output[measure] += entry[measure];
                });
            });
            return output;
        }
        /* Checks that all the dimension names exist */
        _dimensions.forEach(dimension => {
            if (!this.dimensions.hasOwnProperty(dimension))
                throw new Error(`Field "${dimension}" does not exist`);
        });
        /* Creates nested objects if it doesn't exist, and sum over the measures
         * current keeps track of level of nesting in output object */
        dataEntries.forEach(dataEntry => {
            let current = output;
            _dimensions.forEach((dimension, idx) => {
                const dimensionValue = dataEntry[dimension];
                const lastItemIndex = _dimensions.length - 1;
                if (current[dimensionValue] == null) {
                    if (idx === lastItemIndex) {
                        const subsetOfEntry = {};
                        _measures.forEach(measure => subsetOfEntry[measure] = dataEntry[measure]);
                        _dimensions.forEach(dimension => subsetOfEntry[dimension] = dataEntry[dimension]);
                        current[dimensionValue] = subsetOfEntry;
                    }
                    else {
                        current[dimensionValue] = {};
                    }
                }
                else {
                    if (idx === lastItemIndex) {
                        _measures.forEach(measure => current[dimensionValue][measure] += dataEntry[measure]);
                    }
                }
                current = current[dimensionValue];
            });
        });
        return output;
    }
    get length() {
        return this.entries.length;
    }
}

exports.MultidimensionalMap = MultidimensionalMap;
exports.OrderedMap = OrderedMap;
